#                                     НЕОБЯЗАТЕЛЬНЫЕ И ИМЕНОВАННЫЕ АРГУМЕНТЫ

#               Позиционные аргументы
# Все ранее написанные нами функции имели позиционные аргументы. Такие аргументы передаются без указания имен.
# Они называются позиционными, потому что именно по позиции, расположению аргумента, функция понимает, какому параметру он соответствует

# def diff(x, y):
#     return x - y
#
#
# res = diff(10, 3)    # используем позиционные аргументы
# print(res)


#                Именованные аргументы

# Аргументы, передаваемые с именами, называются именованными. При вызове функции можно использовать имена параметров из ее определения.
# Исключение составляют списки аргументов неопределенной длины, где используются аргументы со звездочкой
# def diff(x, y):
#     return x - y
#
#
# res = diff(x=10, y=3)   # используем именованные аргументы
# print(res)

#       ***************         Когда стоит применять именованные аргументы           ****

# Каких-то строгих правил на этот счёт не существует. Однако широко практикуется такой подход: если функция принимает
# больше трёх аргументов, нужно хотя бы часть из них указать по имени. Особенно важно именовать значения аргументов,
# когда они относятся к одному типу, ведь без имен очень трудно понять, что делает функция с подобным вызовом


# def make_circle(x, y, radius, line_width, fill):
#     # тело функции
#
# make_circle(200, 300, 17, 2.5, True)
#
# make_circle(x=200, y=300, radius=17, line_width=2.5, fill=True)

# Комбинирование позиционных и именованных аргументов

# Мы можем вызывать функции, используя именованные и позиционные аргументы одновременно. Но позиционные значения должны быть указаны до любых именованных!

# res = diff(10, y=3)   # используем позиционный и именованный аргумент

#           *************       Необязательные аргументы        **********
# num = int('101', 2)     # аргумент 2 указывает на то, что число 101 записано в двоичной системе


# Чтобы задать значение параметра по умолчанию, в списке параметров функции достаточно после имени переменной написать знак равенства и нужное значение.

# Поскольку обычно нам нужно рисовать круг с шириной линии, равной 1 с заливкой, то логично установить данные значения в качестве значений по умолчанию:

# def make_circle(x, y, radius, line_width=1, fill=True):
#     # тело функции
#
# make_circle(100, 50, 20)
#
# make_circle(x=100, y=50, radius=20, fill=False)                   # line_width=1, fill=False
# make_circle(x=100, y=50, radius=20, line_width=3)                 # fill=True, line_width=3
# make_circle(x=100, y=50, radius=20, line_width=5, fill=False)     # line_width=5, fill=False


#       ****************        Изменяемые типы в качестве значений по умолчанию        **************

# def append(element, seq=[]):
#     seq.append(element)
#     return seq

# Значение по умолчанию для параметра создается единожды при определении функции (обычно при загрузке модуля) и
# становится атрибутом (свойством) функции. Поэтому, если значение по умолчанию изменяемый объект, то его изменение повлияет на каждый следующий вызов функции

# Для решения проблемы можно использовать константу None в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение
# def append(element, seq=None):
#     if seq is None:
#         seq = []
#     seq.append(element)
#     return seq


# Примечание 1. При написании функций стоит указывать более важные параметры первыми.
#
# Примечание 2. Именованные аргументы часто используют вместе со значениями по умолчанию.
#
# Примечание 3. Именованные и позиционные аргументы не всегда хорошо ладят друг с другом. При вызове функции позиционные аргументы должны обязательно идти перед именованными аргументами.
#
# Примечание 4. Параметр в программировании — принятый функцией аргумент. Термин «аргумент» подразумевает, что конкретно и какой конкретной функции было передано, а параметр — в каком качестве функция применила это принятое. То есть вызывающий код передает аргумент в параметр, который определен в описании (заголовке) функции.
#
# Parameter → Placeholder (заполнитель принадлежит имени функции и используется в теле функции);
# Argument → Actual value (фактическое значение, которое передается при вызове функции).

# **********
# def fancy(length, char1, char2):
#     return (char1 + char2) * length + char1
#
#
# print(fancy(5, '-', '*'))

# ***************
# def fancy(length, char1='-', char2='*'):
#     return (char1 + char2) * length + char1
#
#
# print(fancy(3))


# def prt(h='lol', j='k'):
#     return h + j
#
# print(prt('hh'))

# ****************
# def fancy(length, char1='-', char2='*'):
#     return (char1 + char2) * length + char1
#
#
# print(fancy(3, '.'))

# *************
# def fancy(length, char1='-', char2='*'):
#     return (char1 + char2) * length + char1
#
#
# print(fancy(2, ':', '|'))


# *********************
# def fancy(length, char1='-', char2='*'):
#     return (char1 + char2) * length + char1
#
#
# print(fancy(4, char2='#'))

# ***********
# def fancy(length, char1='-', char2='*'):
#     return (char1 + char2) * length + char1
#
#
# print(fancy(char2='$', length=3))

# def fancy(length, char1='-', char2='*'):
#     return (char1 + char2) * length + char1
#
#
# print(fancy(char2='!'))

# **************
# def matrix(n=1, m=None, value=0):
#     if m is None:
#         m = n
#         return [[value] * m] * n
#     else:
#         return [[value] * m] * n


# ************** (ОТ ПРЕПОДАВАТЕЛЯ)
# def matrix(n=1, m=None, value=0):
#     if m is None:
#         m = n
#     return [[value] * m for _ in range(n)]

